<style>
    .highlight
    {
        color: red;
    }

    .footnote
    {
        color: gray;
        font-size: 90%;
    }

    img
    {
        display: block;
        margin: auto;
    }

    .img-desc
    {
        color: gray;
        text-align: center;
        margin-bottom: 1%;
    }
</style>

# CPU의 작동 원리
## 4-1. ALU와 제어장치
- ALU
![Alt text](image.png)
    - 레지스터를 통해 피연산자를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 제어 신호를 받아들임. 이를 기반으로 다양한 연산 수행함. 만약, 결괏값이 있을 경우 레지스터에 저장하고, 이와 더불어 플래그도 내보냄
    - 오버플로우(Overflow) : 연산 결과가 연산 결과를 담을 레지스터보다 큰 상황

- 플래그는 플래그 레지스터에 저장됨.
| 플래그 종류 | 의미 | 사용 예시 |
| --- | --- | --- |
| 부호 플래그 | 연산한 결과의 부호를 나타낸다. | 1인 경우 음수, 0인 경우 양수 |
| 제로 플래그 | 연산 결과가 0인지 여부를 나타낸다. | 1인 경우 0, 0인 경우 0이 아님 |
| 캐리 플래그 | 연산 결과 올림수나 빌림수가 발생했는지를 나타낸다. | 1일 경우 발생, 0일 경우 발생하지 않음 |
| 오버플로우 플래그 | 오버플로우가 발생했는지를 나타낸다. | 1일 경우 발생, 0일 경우 발생하지 않음. |
| 인터럽트 플래그 | 인터럽트가 가능한지를 나타낸다. | 1일 경우 가능, 0일 경우 불가능함. |
| 슈퍼바이저 플래그 | 커널 모드인지, 사용자 모드인지 나타낸다. | 1일 경우 커널 모드, 0일 경우 사용자 모드 |

- 가산기, 보수기, 시프터, 오버플로우 검출기 등

- 제어장치
![Alt text](image-1.png)
    - CPU의 구성 요소 중 가장 정교하게 설계된 부품으로, CPU 제조사마다 제어장치의 구현 방식이나 명령어를 해석하는 방식, 받아들이고 내보내는 정보에는 조금씩 차이가 있음.
    - 받아들이는 정보
        - 클럭 신호
            - 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위
        - 해석해야 할 명령어
            - 명령어 레지스터로부터 명령어를 받아들이고 해석한 뒤, 제어 신호 발생시킴
        - 플래그 값
            - 이를 참고해 제어 신호 발생시킴.
        - 제어 버스로 전달된 제어 신호
            - CPU 외부 장치에서 발생한 제어 신호도 받아들임.
    - 내보내는 정보
        - CPU 내부에 전달
            - ALU에 수행할 연산 지시
            - 레지스터 간 데이터를 이동시키거나 데이터에 저장된 명령어를 해석하기 위해
        - CPU 외부에 전달
            - 제어 버스로 제어 신호를 내보내며, 메모리 혹은 입출력장치에 전달
                - 메모리로부터 읽어들이고 싶을 때 / 메모리에 쓰고 싶을 때
                - 입출력장치에 읽기 혹은 쓰기를 하고 싶을 때

## 4-2. 레지스터
- 프로그램 카운터(PC; Program Counter)
    - 메모리에서 가져올 명령어의 주소
    - 명령어 포인터(IP; Instruction Pointer)라고도 함.
- 명령어 레지스터(IR; Instruction Register)
    - 명령어를 저장하는 레지스터, 해석할 명령어
    - 제어장치는 여기에 저장된 명령어를 해석한 뒤 제어 신호를 내보냄.
- 메모리 주소 레지스터(MAR; Memory Address Register)
    - 메모리의 주소를 저장
    - CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거치게 됨.
- 메모리 버퍼 레지스터(MBR; Memory Buffer Register)
    - 메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터
    - 데이터 버스로 주고받을 값은 MBR을 거침
    - 메모리 데이터 레지스터(MDR; Memory Data Register)라고도 함.
- 범용 레지스터(General Purpose Register)
    - CPU가 임시값을 저장하기 위해 사용하는 레지스터
- 플래그 레지스터
    - 연산 결과 혹은 CPU 상태에 대한 부가적인 정보를 저장
- 스택 포인터(SP; Stack Pointer)
    - 스택에 마지막으로 저장한 값의 위치(Top)를 저장하는 레지스터
    - 스택 주소 지정 방식에 사용
        - 스택 영역을 사용함.
- 베이스 레지스터(Base Register)

- 변위 주소 지정 방식(Displacement Addressing Mode)
    - 오퍼랜드에 저장된 변위와 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 방식
    - 상대 주소 지정 방식(Relative Addressing Mode)
        - 오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻음
        - 분기문이 나올 때 사용
    - 베이스 레지스터 주소 지정 방식(Base-register Addressing Mode)
        - 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻음

### 대표적인 ARM 레지스터
- 13개의 범용 목적 레지스터: `R0` 부터 `R12`
- 스택 포인터: `SP` (`R13`)
- 링크 레지스터: `LR` (`R14`) 함수 호출 등의 서브루틴에서 되돌아갈 주소(리턴 주소)를 저장하기 위해 주로 사용됩니다.
- 프로그램 카운터: `PC` (`R15`)
- 프로그램 상태 레지스터(≒플래그 레지스터): `CPSR`
- 실행 모드에 따라 사용되는 레지스터의 종류가 다름
    1. `User mode`: 사용자 모드로 실행할 때의 동작 모드
    2. `FIQ(Fast Interrupt Request) mode`: 빠르게 처리해야 하는 인터럽트를 처리하기 위한 동작 모드
    3. `IRQ(Interrupt Request) mode`: 일반적인 인터럽트를 처리하기 위한 동작 모드
    4. `SVC(Supervisor) mode`: 자원에 접근할 수 있는 동작 모드
    5. `Abort mode`: 예기치 못한 오류가 발생했을 때의 동작 모드
    6. `Undefined`: 정의되지 않은 명령어를 수행하려 할 때의 동작 모드
    7. `System mode`: 사용자 모드에서 추가적인 권한을 더 부여한 실행 모드

```
링크 레지스터는 범용 레지스터로서 사용될 수도 있습니다. 또한 스택 포인터는 ARM 상태에서 범용 레지스터로 사용될 수 있습니다.

여기서 ARM 상태(ARM state)란 ARM에서는 명령어를 실행할 때 ARM 상태로 실행할 수 있고, Thumb 상태로 실행할 수 있는데, 
전자는 32비트 명령어를 실행하는 모드이고 후자는 16비트 명령어를 실행하는 모드입니다. 

그렇기에 Thumb 상태에서는 ARM 상태로 명령어를 실행할 때에 비해 적은 명령어를 사용합니다. 
Thumb 모드에서는 R0~R7(범용 레지스터 8개), R13(SP), R14(LR), R15(PC) 레지스터를 사용하고, 
ARM mode는 이보다 많은 R0~R12까지 모두 사용할 수 있습니다. 자세한 내용은 이 관련 문서[2]를 확인해보세요.
```

### 대표적인 x86(x86-64) 레지스터
![Alt text](image-3.png)
1. AX (Accumulator register): 산술 연산에 사용.
2. CX (Counter register): 시프트/회전 연산과 루프에서 사용.
3. DX (Data register): 산술 연산과 I/O 명령에서 사용.
4. BX (Base register): 데이터의 주소를 가리키는 포인터로 사용. 
5. SP (Stack Pointer register): 스택의 최상단을 가리키는 포인터로 사용.
6. BP (Stack Base Pointer register): 스택의 베이스(최하단)를 가리키는 포인터로 사용.
7. SI (Source Index register): 스트림 명령에서 소스를 가리키는 포인터로 사용.
8. DI (Destination Index register): 스트림 명령에서 도착점을 가리키는 포인터로 사용
    - E / R

- 명령어 포인터(IP)
- EFLAGS 레지스터 : 플래그 레지스터
- 세그먼트 레지스터(Segment Register) : 주소 지정에서 사용되는 레지스터
    - Stack Segment (SS): 스택을 가리킴.
    - Code Segment (CS): 코드를 가리킴.
    - Data Segment (DS): 데이터를 가리킴.
    - Extra Segment (ES): 추가적인 데이터를 가리킴.
    - F Segment (FS): 많은 추가적인 데이터를 가리킴.
    - G Segment (GS): 더 많은 추가적인 데이터를 가리킴.

## 4-3. 명령어 사이클과 인터럽트
- 명령어 사이클(Instruction Cycle)
    - 하나의 명령어를 처리하는 정형화된 흐름
![Alt text](image-2.png)
    <!-- 각 사이클이 어떻게 일어나는지 .. -->
    1. 인출 사이클(Fetch Cycle) : 메모리로부터 명령어를 CPU로 가져옴
    2. 실행 사이클(Execution Cycle) : 명령어를 해석하고 제어 신호 발생시킴
    3. 간접 사이클(Indirect Cycle) : 메모리 접근이 필요한 경우
    4. 인터럽트 사이클(Interrupt Cycle) 
- 인터럽트(Interrupt)
    - 명령어 사이클의 흐름이 끊어지는 상황 / CPU의 작업을 방해하는 신호
    - 종류
        - 동기 인터럽트(Synchronous Interrupts)
            - CPU에 의해 발생하는 인터럽트
            - CPU가 명령어들을 수행하다가 예상치 못한 상황에 마주쳤을 때, 가령 CPU가 실행하는 프로그램 상 오류와 같은 예외적인 상황에 마주쳤을 때 발생하는 인터럽트
            - 예외가 발생하면 예외를 처리함.
            - 예외(Exception)라고도 함.
                - 폴트(Fault)
                    - 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개
                    - Ex. 필요한 데이터가 보조기억장치에 있는 경우
                - 트랩(Trap)
                    - 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개
                    - Ex. 디버깅
                - 중단(Abort)
                    - 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류
                - 소프트웨어 인터럽트(Software Interrupt)
                    - 시스템 호출이 발생

        - 비동기 인터럽트(Asynchronous Interrupts)
            - 주로 입출력장치에 의해 발생하는 인터럽트
            - 알림 역할을 함.
            - 하드웨어 인터럽트
                1. 입출력장치는 CPU에 인터럽트 요청 신호를 보낸다.
                2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.
                3. CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다.
                4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 스택에 백업한다.
                5. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행한다.            
                6. 인터럽트 서비스 루틴 실행이 끝나면 (4)에서 백업해 둔 작업을 복구하여 실행을 재개한다.
            - 막을 수 있는 인터럽트(Maskable Interrupt)와 막을 수 없는 인터럽트(Non Maskable Interrupt)가 있음.
                - 막을 수 없는 인터럽트는 인터럽트 플래그가 비활성화 되어 있더라도 무시함.
                - 정전이나 하드웨어 고장 등
    - 인터럽트 서비스 루틴(ISR; Interrupt Service Routine)
        - 인터럽트를 처리하기 위한 프로그램
        - 메모리에 저장됨.
        - 인터럽트 핸들러(Interrupt Handler)라고도 함.
    - 인터럽트 벡터(Interrupt Vector)
        - ISR을 식별하기 위한 정보로 각 ISR의 시작 주소가 저장됨.
            - 인터럽트 핸들러는 입출력장치마다 다르기 때문
        - 요청을 보낸 대상으로부터 데이터 버스를 통해 인터럽트 벡터를 전달 받음.

# 참고자료
- https://github.com/kangtegong/self-learning-cs/blob/main/registers/registers.md